# resolve
浏览器渲染过程

###1.从浏览器发出请求开始
* 浏览web的内容是存储在web服务器上，而服务器使用的是http协议
* web服务器会为所有http对象数据附加一个MIME类型（MIME类型即text/html、image/gif等）
* 服务器资源名称为URI，URI有两种形式，一种是URL，描述了一台特定服务器上某资源的特定位置。还有一种是URN（试验阶段）
* 通过URL（机器IP地址）获得http服务器的IP地址和端口号。如果是文本形式的域名通过DNS将主机名转换为IP地址
* 浏览器向服务器发出请求后，服务器返回html文件

###2.浏览器加载顺序
####解析html以构建DOM树 -> 构建渲染树 -> 布局渲染树 -> 绘制渲染树
* 浏览器开始载入html代码，发现head标签内有一个link标签引用外部css文件，那么浏览器发出css文件的请求，等待服务器返回css文件。同事渲染树会被样式文件阻塞，css文件下载不下来，body的内容是不会显示出来
* 浏览器把所有样式(主要包括css和浏览器的样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式
* 浏览器把获取到的html代码解析成一个Dom树，html中的每个tag都是Dom树中的1个节点，根节点是document对象，里面包含了所有的html tag。包括display:none隐藏、JS动态添加的元素等
* DOM树和样式结构体结合后构建呈现渲染树,渲染树能识别样式，渲染树中每个node都有自己的style，渲染树不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到渲染树中。（注意 visibility:hidden隐藏的元素还是会包含到渲染树中的，因为visibility:hidden 会影响布局，会占有空间。）
* 浏览器发现script标签，立刻执行js，如果JS命令浏览器隐藏掉某个<div>,浏览器将重新渲染这部分代码。浏览器发现<img>标签引用了一张图片，向服务器发出请求，浏览器不会等到图片下载完，而是继续渲染后面的代码，服务器返回图片文件，由于图片占据了一定面积，影响了后面的排版，因此浏览器需要回头重新渲染这部分代码。如果js让浏览器换了<link>的css标签，浏览器将向服务器请求了新的CSS文件，重新渲染页面。
* 渲染树构建完毕后，浏览器就可以根据渲染树来绘制页面了
* 一些不会阻塞页面渲染的情况：
    * 定义的defer属性和async属性的
    * 没有匹配的媒体类型的样式文件
    * 没有通过解析器插入script节点或样式节点

###3.reflow、repaint
* 当渲染树因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(重新布局)。每个页面至少需要一次回流，就是在页面第一次加载的时候。
* 当渲染树中更新的属性只影响元素的外观，而不会影响布局时，就叫称为重绘。(注：回流必将引起重绘，而重绘不一定会引起回流。)
* 回流跟渲染树有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个渲染树回流。但如果在body后面插入1个元素，则不会影响前面元素的回流
* 浏览器会优化多次回流（reflow）/重绘（repaint）这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会把flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。有些属性能让浏览器提前flush队列，如offsetTop,scrollTop,clientTop，width，height，getComputedSytle，currentStyle等
* 减少重绘，回流
    * 1，使用className，使用cssText(CSSText会覆盖原本的样式)
    * 2,使用documentFragment，把要添加的元素添加到一个div里面，然后把div放到对应的容器里。先display：none元素，然后对元素进行操作，最后显示元素。因为display:none的元素操作不会引起回流和重绘。这样只有两次回流
    * 3，减少访问会引起浏览器flush队列的属性。将flush队列的元素保存在变量中，然后操作变量（可放入循环中）
    * 4，使用left需要重绘,但不会引起回流。使用marginLeft会引起重绘，会影响其他元素的回流
    * 5，尽量不是用table布局，table容易重新布局
